<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>File-Like ICN Collection (FLIC)</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 FLIC as a Distributed Data Structure"/>
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Design goals"/>
<link href="#rfc.section.2" rel="Chapter" title="2 File-Like ICN Collection (FLIC) Format"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Use of hash-valued pointers"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Creating a FLIC data structure"/>
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Reconstructing the collection&#x2019;s data"/>
<link href="#rfc.section.2.4" rel="Chapter" title="2.4 Metadata in HashGroups"/>
<link href="#rfc.section.2.5" rel="Chapter" title="2.5 Locating FLIC leaf and manifest nodes"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Advanced uses of FLIC manifests"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Seeking"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Block-level de-duplication"/>
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Growing ICN collections"/>
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Re-publishing a FLIC under a new name"/>
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 Data Chunks of variable size"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Encoding"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Example Encoding for CCNx1.0"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Example Encoding for NDN"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="6 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Tschudin, C. and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-icnrg-flic-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-6-26" />
  <meta name="dct.abstract" content="This document describes a bare bones &#8220;index table&#8221;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC)." />
  <meta name="description" content="This document describes a bare bones &#8220;index table&#8221;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC)." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">ICNRG</td>
  <td class="right">C. Tschudin</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">University of Basel</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: December 28, 2017</td>
  <td class="right">University of California Irvine</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">June 26, 2017</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">File-Like ICN Collection (FLIC)<br />
  <span class="filename">draft-irtf-icnrg-flic-latest</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes a bare bones &#8220;index table&#8221;-approach for organizing a set of ICN data objects into a large, File-Like ICN Collection (FLIC).</p>
<p>At the core of this collection is a so called manifest which acts as the collection&#8217;s root node. The manifest contains an index table with pointers, each pointer being a hash value pointing to either a final data block or another index table node.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 28, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">FLIC as a Distributed Data Structure</a></li>
<li>1.2.   <a href="#rfc.section.1.2">Design goals</a></li>
</ul><li>2.   <a href="#rfc.section.2">File-Like ICN Collection (FLIC) Format</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Use of hash-valued pointers</a></li>
<li>2.2.   <a href="#rfc.section.2.2">Creating a FLIC data structure</a></li>
<li>2.3.   <a href="#rfc.section.2.3">Reconstructing the collection&#8217;s data</a></li>
<li>2.4.   <a href="#rfc.section.2.4">Metadata in HashGroups</a></li>
<li>2.5.   <a href="#rfc.section.2.5">Locating FLIC leaf and manifest nodes</a></li>
</ul><li>3.   <a href="#rfc.section.3">Advanced uses of FLIC manifests</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Seeking</a></li>
<li>3.2.   <a href="#rfc.section.3.2">Block-level de-duplication</a></li>
<li>3.3.   <a href="#rfc.section.3.3">Growing ICN collections</a></li>
<li>3.4.   <a href="#rfc.section.3.4">Re-publishing a FLIC under a new name</a></li>
<li>3.5.   <a href="#rfc.section.3.5">Data Chunks of variable size</a></li>
</ul><li>4.   <a href="#rfc.section.4">Encoding</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Example Encoding for CCNx1.0</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Example Encoding for NDN</a></li>
</ul><li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#flic-as-a-distributed-data-structure" id="flic-as-a-distributed-data-structure">FLIC as a Distributed Data Structure</a></h1>
<p id="rfc.section.1.1.p.1">One figure</p>
<div id="rfc.figure.1"/>
<div id="manifest"/>
<pre>
                          root manifest
  .------------------------------------.
  | optional name:                     |
  |   /icn/name/of/this/flic           |
  |                                    |
  | HashGroup (HG):                    |
  |   optional metadata:               |
  |     overall digest, locator, etc.  |    .------.
  |   hash-valued data pointer -----------&gt; | data |
  |     ...                            |    `------'  sub manifest
  |   hash-valued manifest pointer ------.     .------------------.
  |                                    |  `--&gt; |                -----&gt;
  | optional additional HashGroups ..  |       |                -----&gt;
  |                                    |       `------------------'
  | optional signature                 |
  `------------------------------------'
</pre>
<p class="figure">Figure 1: A FLIC manifest and its directed acyclic graph</p>
<h1 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a> <a href="#design-goals" id="design-goals">Design goals</a></h1>
<p/>

<ul>
  <li>Copy the proven UNIX inode concept: <ul><li>index tables and memory pointers</li></ul></li>
  <li>Adaption to ICN: <ul><li>hash values instead of block numbers, unique with high probability</li></ul></li>
  <li>Advantages (over non-manifest collections): <ul><li>single root manifest signature covers all elements of the full collection, including intermediate sub manifests</li><li>eliminate reference to chunk numbering schemata (hash values only)</li><li>supports block-level de-duplication (can lead to a directed acyclic graph, or DAG, instead of a tree)</li></ul></li>
  <li>Limitations <ul><li>All data leafs must be present at manifest creation time (otherwise one cannot compute the pointers)</li></ul></li>
  <li>Potential extensions (for study): <ul><li>Enhance the manifest such that it can serve as a &#8220;database cursor&#8221; or as a cursor over a time series, e.g. having entries for &#8220;previous&#8221; and &#8220;next&#8221; collections.</li></ul></li>
</ul>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#file-like-icn-collection-flic-format" id="file-like-icn-collection-flic-format">File-Like ICN Collection (FLIC) Format</a></h1>
<p id="rfc.section.2.p.1">We first give the FLIC format in EBN notation:</p>
<pre>
   ManifestMsg := Name? HashGroup+

   HashGroup   := MetaData? (SizeDataPtr | SizeManifestPtr)+
   BlockHashGroup := MetaData? SizePerPtr (DataPtr | ManifestPtr)+

   DataPtr := HashValue
   ManifestPtr := HashValue
   SizeDataPtr := Size HashValue
   SizeManifestPtr := Size HashValue

   SizePerPtr    := Size
   HashValue     := See {{CCNxMessages}}
   Size          := OCTET[8]

   MetaData    := Property*
   Property    := Locator | OverallByteCount | OverallDataDigest | ...
</pre>
<p id="rfc.section.2.p.2">Description:</p>
<p/>

<ul>
  <li>The core of a manifest is the sequence of &#8220;hash groups&#8221;.</li>
  <li>A HashGroup (HG) consists of a sequence of &#8220;sized&#8221; data or manifest pointers.</li>
  <li>A BlockHashGroup (BHG) consists of a sequence of data or manifest pointers and a mandatory field that lists the total size of each pointer. These HashGroups should be used when each pointer (except the last) contains an identical number of application bytes.</li>
  <li>Sizes are 64-bit unsigned integers.</li>
  <li>Data and manifest pointers are cryptographic HashValues encoded according to the mechanism listed in <a href="#CCNxMessages">[CCNxMessages]</a>. Specifically, a HashValue specifies the cryptographic hash algorithm and the actual digest.</li>
  <li>A HashGroup can contain a metadata section to help a reader to optimize content retrieval (block size of leaf nodes, total size, overall digest etc).</li>
  <li>None of the ICN objects used in FLIC are allowed to be chunked, including the (sub-) manifests. The smallest possible complete manifest contains one HashGroup with one pointer to an ICN object.</li>
</ul>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#use-of-hash-valued-pointers" id="use-of-hash-valued-pointers">Use of hash-valued pointers</a></h1>
<p id="rfc.section.2.1.p.1">FLIC&#8217;s tree data structure is a generalized index table as it is known from file systems. The pointers, which in an OS typically are hard disk block numbers, are replaced by hash values of other ICN objects. These ICN objects contain either other manifest nodes, or leaf nodes. Leafs contain the actual data of the collection. Each pointer explicitly indicates the amount of application data bytes contained by the referred object. For example, the size of a data pointer (to a leaf) represents the size of the leaf&#8217;s content object payload. Conversely, the size of a manifest pointer represents the total size of all pointers contained in that manifest.</p>
<p id="rfc.section.2.1.p.2">FLIC makes use of &#8220;nameless ICN object&#8221; where the network is tasked with fetching an object based on its digest only. The interest for such an object consists of a routing hint (locator) plus the given digest value.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#creating-a-flic-data-structure" id="creating-a-flic-data-structure">Creating a FLIC data structure</a></h1>
<p id="rfc.section.2.2.p.1">Starting from the original content, the corresponding byte array is sliced into chunks. Each chunk is encoded as a data object, according the ICN suite.  For each resulting data object, the hash value is computed. Groups of consecutive objects are formed and the corresponding hash values collected in manifests, which are also encoded. The hash values of the manifest objects replace the hash values of the covered leaf nodes, thus reducing the number of hash values. This process of hash value collection and replacement is repeated until only one (root) manifest is left.</p>
<pre>
data1 &lt;-- h1  -  -  -  -  -  -  -  -  -  -  -  - \
data2 &lt;-- h2 \                                    root mfst
...            mfst 1 &lt;-- hN+1  \                /
dataJ &lt;-- hJ /                    mfst2 &lt;-- hN+2
...                              /
dataN &lt;-- hN  -  -  -  -  -  -  /
</pre>
<p id="rfc.section.2.2.p.2">Of special interest are &#8220;skewed trees&#8221; where a pointer to a manifest may only appear as last pointer of (sub-) manifests. Such a tree becomes a sequential list of manifests with a maximum of datapointers per manifest packet. Beside the tree shape we also show this data structure in form of packet content where D stands for a data pointer and M is the hash of a manifest packet.</p>
<pre>
data1   &lt;-- h1  -  -  -  -  -  -  -  -  root mfst
...                                    /
dataJ-1 &lt;-- hJ-1                      /
dataJ   &lt;-- hJ  -  -  mfst1 &lt;-- hN+1 /
...                /
dataN   &lt;-- hN  - /

DDDDDDM--&gt; DDDDDDM--&gt; ....... DDDDDDM--&gt; DDDDDDD
</pre>
<p id="rfc.section.2.2.p.3">A pseudo code description for producing a skewed tree follows below.</p>
<pre>
Input:
    Application data D of size |D| (bytes)
    Block size B (in bytes)
Output:
    FLIC root node R
Algo:
    n = number of leaf nodes = ceil(|D| / B)
    k = number of (encoded) hash values fitting in a block of size B
    H[1..n] = array of hash values
      initialized with the data hash values for data chunks 1..n
    While n &gt; k do
      a)  create manifest M with a HashGroup
      b)  append to the HashGroup in M all hash values H[n-k+1..n]
      c)  n = n - k + 1
      d)  H[n] = manifest hash value of M
    Create root manifest R with a HashGroup
    Add to the HashGroup of R all hash values H[1..n]
    Optionally: add name to R, sign manifest R
    Output R
</pre>
<p id="rfc.section.2.2.p.4">Obtaining with each manifest a maximum of data pointers is beneficial for keeping the download pipeline filled. On the other hand, this tree doesn&#8217;t support well random access to arbitrary byte positions: All data pointers coming before that offset have to be fetched before locating the block of interest. For random access, binary trees (where both subtrees of a node cover half of the content bytes) are better suited. This can be combined with the &#8220;skewed tree&#8221; approach: Manifests of intermediate nodes are filled with data pointers except for the last two slots. The second last slot points to a manifest for the &#8220;first half&#8221; of the left content, the last slots then points to a manifest for the rest.</p>
<pre>
root manifest=     DDDDDMM
           ____________/  \_____
          /                     \
          DDDDDMM                DDDDDMM
       _______/  \              _____/  \
      /           \            /         \
      DDDDDDD      DDDDDDD     DDDDDDD    DDDDDDD
</pre>
<p id="rfc.section.2.2.p.5">This can be generalized to k-ary trees by allocating k pointers per manifest instead of 2.</p>
<h1 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a> <a href="#reconstructing-the-collections-data" id="reconstructing-the-collections-data">Reconstructing the collection&#8217;s data</a></h1>
<p id="rfc.section.2.3.p.1">To fetch the data associated with a given FLIC (sub-) manifest, the receiver sequentially works through all entries found in the HashGroups and issues corresponding hash-based interests. In case of a data hash pointer, the received content object is appended. In case of a manifest hash pointer, this procedure is called recursively for the received manifest. In other words, the collection data is represented as the concatenation of data leaves from this <em>pre-order</em> depth-first search (DFS) traversal strategy of the manifest tree. (Currently, pre-order DFS is the only supported traversal strategy.) This procedure works regardless of the tree&#8217;s shape.</p>
<p id="rfc.section.2.3.p.2">A pseudo code description for fetching is below.</p>
<pre>
Input:
    Root manifest R
Output:
    Application data D
Algo:
    global D = []
    DFS(R)
    Output D

where:

procedure DFS(M)
{
L:
  H = sequence of hash valued pointers of M
  foreach p in H do:
    if p is a data pointer then
      data = lookup(p)
      Append data to D
    else
      M = lookup(p)
      if p is last element in H then
        goto L;   // tail recursion
      DFS(M)
}
</pre>
<p id="rfc.section.2.3.p.3">The above DFS code works for FLIC manifest trees of arbitrary shape. In case of a skewed tree, no recursion is needed and a single instance of the DFS procedure suffices (i.e., one uses tail recursion).</p>
<h1 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a> <a href="#metadata-in-hashgroups" id="metadata-in-hashgroups">Metadata in HashGroups</a></h1>
<p id="rfc.section.2.4.p.1">In FLIC, metadata is linked to HashGroups and permits to inform the FLIC retriever about properties of the data that is covered by this hash group. Examples are overall data bytes or the overall hash digest (this is akin to a Merkle hash). The intent of such metadata is to enable an in-network retriever to optimize its operation - other attributes linked to the collection as a whole (author, copyright, etc.) is out of scope.</p>
<p id="rfc.section.2.4.p.2">The list of available metadata is below.</p>
<pre>
* Locator - provides a new routing hint (name prefix) where the
  chunks of this hash group can be retrieved from. The default is to
  use the locator of the root manifest.

* OverallByteCount - indicates the total number of *application
  data bytes* contained in a single HashGroup. This does not include
  bytes consumed by child manifests. This value is equal to the sum of
  all pointer sizes contained in the HashGroup.

* OverallDataDigest - expresses the overall digest of all application
  data contained in the HashGroup.
</pre>
<p id="rfc.section.2.4.p.3">BlockHashGroups contain a mandatory piece of metadata called the SizePerPtr.  This value indicates the total number of application bytes contained within each pointer in the hash group <em>except for the last pointer.</em> Normal HashGroups do not require this piece of metadata; Instead, each pointer includes their size explicitly.</p>
<h1 id="rfc.section.2.5"><a href="#rfc.section.2.5">2.5.</a> <a href="#locating-flic-leaf-and-manifest-nodes" id="locating-flic-leaf-and-manifest-nodes">Locating FLIC leaf and manifest nodes</a></h1>
<p id="rfc.section.2.5.p.1">The optional name of a manifest is a mere decoration and has no locator functionality at all: All objects pointed to by a manifest are retrieved from the location where the manifest itself was obtained from (which is not necessarily its name). Example:</p>
<pre>
Objects:
  manifest(name=/a/b/c, ptr=h1, ptr=hN)  - has hash h0
  nameless(data1)                        - has hash h1
  ...
  nameless(dataN)                        - has hash hN

Query for the manifest:
  interest(name=/the/locator/hint, implicitDigest=h0)
</pre>
<p id="rfc.section.2.5.p.2">In this example, the name &#8220;/a/b/c&#8221; does NOT override &#8220;/the/locator/hint&#8221; i.e., after having obtained the manifest, the retriever will issue requests for</p>
<pre>
  interest(name=/the/locator/hint, implicitDigest=h1)
  ...
  interest(name=/the/locator/hint, implicitDigest=hN)
</pre>
<p id="rfc.section.2.5.p.3">Using the locator metadata entry, this behavior can be changed:</p>
<pre>
Objects:
  manifest(name=/a/b/c,
           hashgroup(loc=/x/y/z, ptr=h1)
           hashgroup(ptr=h2)             - has hash h0
  nameless(data1)                        - has hash h1
  nameless(data2)                        - has hash h2

Queries:
  interest(name=/the/locator/hint, implicitDigest=h0)
  interest(name=/x/y/z, implicitDigest=h1)
  interest(name=/the/locator/hint, implicitDigest=h2)
</pre>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#advanced-uses-of-flic-manifests" id="advanced-uses-of-flic-manifests">Advanced uses of FLIC manifests</a></h1>
<p id="rfc.section.3.p.1">The FLIC mechanics has uses cases beyond keeping together a set of data objects, such as: seeking, block-level de-duplication, re-publishing under a new name, growing ICN collections, and supporting FLICs with different block sizes.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#seeking" id="seeking">Seeking</a></h1>
<p id="rfc.section.3.1.p.1">Fast seeking (without having to sequentially fetch all content) works by skipping over entries for which we know their size.  The following expression shows how to compute the byte offset of the data pointed at by pointer P_i, offset_i. In this formula, let P_i represent the Size value of the i-th pointer.</p>
<pre>
   offset_i = \sum_{i = 1}^{i - 1} P_i.size
</pre>
<p id="rfc.section.3.1.p.2">With this offset, seeking is done as follows:</p>
<pre>
Input: seek_pos P, a FLIC manifest with a hash group having N entries
Output: pointer index i and byte offset o, or out-of-range error
Algo:
    offset = 0
    for i in 1..N do
        if (P &lt; P_i.size)
            return (i, P - offset)
        offset += P_i.size
    return out-of-range
</pre>
<p id="rfc.section.3.1.p.3">Seeking in a BlockHashGroup is different since offsets can be quickly computed.  This is because the size of each pointer P_i except the last is equal to the SizePerPtr value. For a BlockHashGroup with N pointers, OverallByteCount D, and SizePerPointer L, the size of P_i is equal to the following:</p>
<pre>
   D - ((i - 1) * L)
</pre>
<p id="rfc.section.3.1.p.4">In a BlockHashGroup with k pointers, the size of P_k is equal to:</p>
<pre>
    D - L * (k - 1)
</pre>
<p id="rfc.section.3.1.p.5">Using these, the seeking algorithm can be thus simplified to the following:</p>
<pre>
Input: seek_pos P, a FLIC manifest with a hash group having
       OverallByteCount S and SizePerPointer L.
Output: pointer index i and byte offset o, or out-of-range error
Algo:
    if (P &gt; S)
        return out-of-range
    i = floor(P / L)
    if (i &gt; N)
        return out-of-range # bad FLIC encoding
    o = P mod L
    return (i, o)
</pre>
<p id="rfc.section.3.1.p.6">Note: In both cases, if the pointer at position i is a manifest pointer, this algorithm has to be called once more, seeking to seek_pos o inside that manifest.</p>
<h1 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#block-level-de-duplication" id="block-level-de-duplication">Block-level de-duplication</a></h1>
<p id="rfc.section.3.2.p.1">Consider a huge file, e.g. an ISO image of a DVD or program in binary form, that had previously been FLIC-ed but now needs to be patched.  In this case, all existing encoded ICN chunks can remain in the repository while only the chunks for the patch itself is added to a new manifest data structure, as is shown in the picture below. For example, the <a href="http://plan9.bell-labs.com/sys/doc/venti/venti.pdf">venti</a> archival file system of Plan9 uses this technique.</p>
<pre>
old_mfst -  - &gt; h1 --&gt; oldData1  &lt;-- h1 &lt; -  -  new_mfst
         \  - &gt; h2 --&gt; oldData2  &lt;-- h2 &lt; -  - /
          \            replace3  &lt;-- h5 &lt; -  -/
           \- &gt; h3 --&gt; oldData3              /
            \ &gt; h4 --&gt; oldData4  &lt;-- h4 &lt; - /
</pre>
<h1 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a> <a href="#growing-icn-collections" id="growing-icn-collections">Growing ICN collections</a></h1>
<p id="rfc.section.3.3.p.1">A log file, for example, grows over time. Instead of having to re-FLIC the grown file it suffices to construct a new manifest with a manifest pointer to the old root manifest plus the sequence of data hash pointers for the new data (or additional sub-manifests if necessary).  Note that this tree will not be skewed (anymore).</p>
<pre>
old data &lt; -  -  -  mfst_old &lt;-- h_old -  - mfst_new
                                            /
new data1 &lt;-- h_1 -  -  -  -  -  -  -  -  -/
new data2                                 /
...                                      /
new dataN &lt;-- h_N -  -  -  -  -  -  -  -/
</pre>
<h1 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a> <a href="#re-publishing-a-flic-under-a-new-name" id="re-publishing-a-flic-under-a-new-name">Re-publishing a FLIC under a new name</a></h1>
<p id="rfc.section.3.4.p.1">It can happen that a publisher&#8217;s namespace is part of a service provider&#8217;s prefix. When switching provider, the publisher may want to republish the old data under a new name. This can easily be achieved with a single nameless root manifest for the large FLIC plus arbitrarily many per-name manifests (which are signed by whomever wants to publish this data):</p>
<pre>
   data &lt; - nameless_mfst() &lt;-- h  &lt; - mfst(/com/parc/east/the/flic)
                                   &lt; - mfst(/com/parc/west/old/the/flic)
                                   &lt; - mfst(/internet/archive/flic234)
</pre>
<p id="rfc.section.3.4.p.2">Note that the hash computation (of h) only requires reading the nameless root manifest, not the entire FLIC.</p>
<p id="rfc.section.3.4.p.3">This example points out the problem of HashGroups having locator metadata elements: A retriever would be urged to follow these hints which are &#8220;hardcoded&#8221; deep inside the FLIC but might have become outdated. We therefore recommend to name FLIC manifests only at the highest level (where these names have no locator function). Child nodes in a FLIC manifest should not be named as these names serve no purpose except retrieving a sub-tree&#8217;s manifest by name, if would be required.</p>
<h1 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5.</a> <a href="#data-chunks-of-variable-size" id="data-chunks-of-variable-size">Data Chunks of variable size</a></h1>
<p id="rfc.section.3.5.p.1">If chunks do not have regular (block) sizes, the HashGroup can be used to still convey to a reader the length of the chunks at the manifest level. (This can be computed based on the size of pointers, but the metadata field makes this determination simpler.) Example use cases would be chunks each carrying a single ASCII line as entered by a user or a database with variable length records mapped to chunks.</p>
<pre>
M = (manifest
      (hashgroup((metadata(SizePerPtr=4096)) (dataptr=h1))
      (hashgroup((metadata(SizePerPtr=1500)) (dataptr=h2))
      ...
    )
</pre>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#encoding" id="encoding">Encoding</a></h1>
<p id="rfc.section.4.p.1">We express the packet encoding of manifests in a symbolic expression style in order to show the TLV structure and the chosen type values. In this notation, a TLV&#8217;s type is a combination of &#8220;SymbolicName/Tvalue&#8221;, Length is not shown and Values are sub-expressions. Moreover, we populate the data structure with all possible entries and omit repetition.</p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#example-encoding-for-ccnx10" id="example-encoding-for-ccnx10">Example Encoding for CCNx1.0</a></h1>
<pre>
[FIXED_HEADER OCTET[8]]
(ManifestMsg/T_MANIFEST
  (Name/T_NAME ...)
  (HashGroup/T_HASHGROUP
     (MetaData/T_HASHGROUP_METADATA
        (HGLocator/T_HASHGROUP_METADATA_LOCATOR (T_NAME ...))
        (HGOverallByteCount/T_HASHGROUP_METADATA_BYTECOUNT INT)
        (HGOverallDataDigest/T_HASHGROUP_METADATA_DATADIGEST OCTET[32])
     )
     (SizeDataPtr/T_HASHGROUP_SIZEDATAPTR OCTET[8] (T_HASH ...))
     (SizeMfstPtr/T_HASHGROUP_SIZEMANIFESTPTR OCTET[8] (T_HASH ...))
  )
  (BlockHashGroup/T_BLOCKHASHGROUP
     (MetaData/T_HASHGROUP_METADATA (...))
     (DataPtr/T_HASHGROUP_DATAPTR OCTET[32] (T_HASH ...))
     (MfstPtr/T_HASHGROUP_MANIFESTPTR OCTET[32] (T_HASH ...))
  )
)
</pre>
<p id="rfc.section.4.1.p.1">Interest: name is locator, use objHashRestriction as selector.</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#example-encoding-for-ndn" id="example-encoding-for-ndn">Example Encoding for NDN</a></h1>
<p id="rfc.section.4.2.p.1">The assigned NDN content type value for FLIC manifests is 1024 (0x400).</p>
<pre>
(Data/0x6
  (Name/0x7 ...)
  (MetaInfo/0x14
    (ContentType/0x18 0x0400)
  )
  (Content/0x15
    (HashGroup/0xC0
      (MetaInfo/0x14
        (LocatorNm/0xC3 (NameComp/0x8 ...))
        (OverallDataDigest/0xC4 OCTET[32])
        (OverallByteCount/0xC5 INT)
      )
      (DataPtr/0xC1 OCTET[8] OCTET[32])
      (MfstPtr/0xC2 OCTET[8] OCTET[32])
      (SizeDataPtr/0xC3 OCTET[32])
      (SizeMfstPtr/0xC4 OCTET[32])
    )
  )
  (SignatureInfo/0x16 ...)
  (SignatureValue/0x17 ...)
)
</pre>
<p id="rfc.section.4.2.p.2">Interest: name is locator, use implicitDigest name component as selector.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">None.</p>
<h1 id="rfc.references"><a href="#rfc.references">6.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="CCNxMessages">[CCNxMessages]</b>
      </td>
      <td class="top"><a>PARC, .</a>, <a>LinkedIn, .</a> and <a>. PARC</a>, "<a href="https://datatracker.ietf.org/doc/draft-irtf-icnrg-ccnxmessages/">CCNx Messages in TLV Format</a>", n.d..</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christian Tschudin</span> 
	  <span class="n hidden">
		<span class="family-name">Tschudin</span>
	  </span>
	</span>
	<span class="org vcardline">University of Basel</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christian.tschudin@unibas.ch">christian.tschudin@unibas.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">University of California Irvine</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:woodc1@uci.edu">woodc1@uci.edu</a></span>

  </address>
</div>

</body>
</html>
